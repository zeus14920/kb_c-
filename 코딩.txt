1.대학생 철수는 새 학기를 맞아 대학 수업 시간표를 만들려고 합니다. 철수는 이번 학기에 총 5가지 과목을 듣고자 하며, 각 과목은 4개의 분반으로 나누어져 있습니다. 즉 1번 과목은 ‘A’분반, ‘B’분반, ‘C’분반, ‘D’분반으로 나누어져 있고, 2,3,4,5번 과목 또한 각각 ‘A’분반, ‘B’분반, ‘C’분반, ‘D’분반으로 나누어져 있습니다. 과목별로 각 분반은 서로 다른 교수님이 강의 하므로, 각 분반의 수업 시간은 서로 다를 수도 있고, 겹칠 수도 있습니다.
철수는 5가지 과목을 모두 들을 수 있도록 각 과목마다 4개의 분반 중 하나씩을 선택하여 시간표를 만들려 합니다.

예를 들어 5개의 과목 분반들의 수업 시간이 서로 다른 과목 분반들의 수업 시간과 전혀 겹치지 않는다면,
철수가 만들 수 있는 시간표는 총 1024(=4 x 4 x 4 x 4 x 4)가지입니다. 하지만 어떤 과목의 분반이 다른 과목의 분반과 수업 시간이 서로 겹치게 된다면 만들 수 있는 시간표의 가짓수는 줄어들게 됩니다.

철수가 만들 수 있는 올바른 시간표는 몇 개인지를 구하려고 합니다. 올바른 시간표란, 듣고자 하는 5개의 과목 중 어떤 과목도 다른 과목과 수업 시간이 겹치지 않는 시간표를 말합니다.

분반의 수업 시작 시각을 과목별로 담은 2차원 문자열 배열 schedule이 매개변수로 주어집니다. 만들 수 있는 올바른 시간표의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항
schedule의 행의 길이 = 5 (들어야 하는 과목 수)
schedule의 열의 길이 = 4 (과목별 분반(A, B, C, D)의 개수)
schedule의 원소는 Day HH:MM 혹은 Day HH:MM Day HH:MM의 형태로 주어집니다.

Day는 요일을 나타내는 문자열입니다. 아래 표에 해당하는 값으로만 주어집니다.
Day	뜻
MO	월요일
TU	화요일
WE	수요일
TH	목요일
FR	금요일
HH는 시간을 나타내는 정수입니다. 9시는 "Day 09:MM"의 형태로 주어집니다.
9 ≤ HH ≤ 18
MM는 분을 나타내는 정수입니다. 0분은 "Day HH:00"의 형태로 주어집니다.
MM은 00이거나 30입니다.
schedule의 원소가 Day HH:MM과 같은 형태인 경우에는 수업이 연속으로 3시간 동안 진행됩니다.
예를 들어, schedule의 원소가 "TU 13:30"인 경우에는 화요일 13시 30분부터 16시 30분까지 진행되는 수업이라는 뜻입니다.
schedule의 원소가 Day HH:MM Day HH:MM과 같은 형태인 경우에는 수업이 1시간 30분 동안 각각 다른 요일에 두 번 진행됩니다.
예를 들어, schedule의 원소가 "TU 13:30 FR 14:30"일 경우는 화요일 13시 30분부터 15시까지, 그리고 금요일 14시 30분부터 16시까지 진행되는 수업이라는 뜻입니다.
Day HH:MM Day HH:MM에서 첫 번째 Day와 두 번째 Day는 다릅니다.
Day HH:MM Day HH:MM에서 첫 번째 Day와 두 번째 Day는 시간순으로 오지 않을 수 있습니다.
예를 들어 "FR 14:30 MO 18:30"와 같이, 금요일이 월요일보다 앞에 오는 입력도 있을 수 있습니다. 물론 "FR 14:30 MO 18:30"과 "MO 18:30 FR 14:30"는 같은 의미의 입력입니다.
Day와 HH:MM는 하나의 공백으로 구분되어 있습니다.
모든 과목 분반의 수업 시간은 1주일에 3시간입니다. 1주일에 한 번, 3시간 연속으로 진행되거나 1주일에 두 번, 1시간 30분씩 진행됩니다.

수업이 끝나는 시각과 다른 수업이 시작하는 시각이 같더라도 수업 시간이 겹치지 않는 것으로 간주합니다.

한 과목 분반의 수업 시작 시간이 같을 수도 있습니다.

예를 들어, 한 과목의 4개의 분반이 모두 같은 시각에 시작할 수도 있습니다.
입출력 예
schedule	result
[["MO 12:00 WE 14:30", "MO 12:00", "MO 15:00", "MO 18:00"], ["TU 09:00", "TU 10:00", "TU 15:00", "TU 18:00"], ["WE 09:00", "WE 12:00", "WE 15:00", "WE 18:00"], ["TH 09:30", "TH 11:30", "TH 15:00", "TH 18:00"], ["FR 15:00", "FR 15:00", "FR 15:00", "FR 15:00"]]	896
입출력 예 설명
입출력 예 #1

첫 번째 과목의 첫 번째 분반인 "MO 12:00 WE 14:30"과, 세 번째 과목의 2, 3번째 분반인 "WE 12:00"와 "WE 15:00"를 제외하고는 서로 수업 시간이 겹치는 과목이 없습니다.

첫 번째 과목을 2, 3, 4번째 분반인 3시간짜리 수업으로 선택했을 경우, 만들 수 있는 올바른 시간표의 개수는 3 x 4 x 4 x 4 x 4 = 768개입니다.
첫 번째 과목을 1번째 분반인 월요일과 수요일 1시간 30분씩 진행하는 수업으로 선택했을 경우, 만들 수 있는 올바른 시간표의 개수는 1 x 4 x 2 x 4 x 4 = 128개입니다.
첫 번째 과목의 수업이 월요일 12시부터 13시 30분까지, 수요일 2시 30분부터 4시까지 진행된다면 3번째 과목의 "WE 12:00"와 "WE 15:00"는 첫 번째 과목과 수업 시간이 겹치므로 선택할 수 없습니다.
따라서 만들 수 있는 올바른 시간표의 개수는 896(768 + 128)개입니다.


2.돌무더기 게임은 여러 돌무더기에서 돌을 하나씩 추가하거나 제거하여, 하나의 돌무더기만 남기는 게임입니다. 게임에서 승리하기 위해서는 마지막에 남은 하나의 돌무더기의 돌 수가 정확히 k개가 되어야 합니다.

처음 주어지는 돌무더기들은 각각 1개 이상의 돌을 갖고 있습니다. 당신은 한 돌무더기를 골라 다음과 같은 행동을 할 수 있습니다.

선택한 돌무더기에 돌을 1개 추가합니다. 동시에, 선택되지 않은 나머지 돌무더기에서 각각 1개씩 돌을 제거합니다.
돌을 제거해야 할 나머지 돌무더기 중에서 제거할 돌이 없는 경우(=돌 수가 0인 경우), 위 행동은 실행할 수 없습니다.
예를 들어 3개의 돌무더기에 돌이 각각 [1, 3, 2]개 있고 k가 3인 경우, 게임에서 승리하는 가장 빠른 방법은 아래와 같이 2가지가 있습니다.

첫 번째 - 세 번째 - 세 번째 돌무더기를 차례대로 선택합니다. 각 선택 시에 돌무더기의 돌 수는 [2, 2, 1] - [1, 1, 2] - [0, 0, 3]과 같이 변합니다.
세 번째 - 첫 번째 - 세 번째 돌무더기를 차례대로 선택합니다. 각 선택 시에 돌무더기의 돌 수는 [0, 2, 3] - [1, 1, 2] - [0, 0, 3]과 같이 변합니다.
선택하는 돌무더기의 인덱스를 순서대로 나열하여 문자열로 변환하면 1번 방법은 "022", 2번 방법은 "202"입니다. 이를 사전 순으로 정렬했을 때, 가장 뒤에 오는 방법은 "202"입니다.

각 돌무더기의 돌 수를 나타내는 정수 배열 stones, 남겨야 하는 한 돌무더기의 돌 수를 나타내는 정수 k가 매개변수로 주어집니다. 게임에서 승리하기 위한 가장 빠른 방법 중에서, 선택하는 돌무더기의 인덱스를 문자열로 변환했을 때 사전 순으로 가장 뒤에 오는 방법을 return 하도록 solution 함수를 완성해주세요. 만약 어떤 방법으로도 목표를 달성할 수 없다면 "-1"을 return 해주세요.

제한사항
2 ≤ stones의 길이 ≤ 8
1 ≤ stones의 원소 ≤ 12
1 ≤ k ≤ 24
돌 수가 0인 돌무더기도 선택할 수 있는 돌무더기입니다.
입출력 예
stones	k	result
[1, 3, 2]	3	"202"
[4, 2, 2, 1, 4]	1	"3213"
[5, 7, 2, 4, 9]	20	"-1"
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

네 번째 - 세 번째 - 두 번째 - 네 번째 순으로 돌무더기를 선택하면 아래 표와 같이 돌 수가 변합니다.

선택한 돌무더기의 인덱스	stones
-	[4, 2, 2, 1, 4]
3	[3, 1, 1, 2, 3]
2	[2, 0, 2, 1, 2]
1	[1, 1, 1, 0, 1]
3	[0, 0, 0, 1, 0]
따라서 "3213"을 return 합니다.

입출력 예 #3

어떤 방법으로도 마지막에 남길 한 돌무더기를 20으로 만들 수 없습니다. 따라서 "-1"을 return 합니다.

3.모든 칸이 동일한 크기의 작은 정삼각형으로 이루어진 정삼각형 모양의 격자가 있습니다. 각 칸은 빨간색 또는 파란색으로 색칠되어 있으며, 당신은 이 격자에서 다음과 같은 규칙으로 움직입니다.

어떤 칸에 입장했을 때, 해당 칸의 색이 빨간색이라면 우회전을, 파란색이라면 좌회전을 해서 나갑니다.
다음 그림은 크기가 2인 격자가 색칠되어 있고, 격자에 입장했다가 퇴장하는 경로 6가지를 나타낸 것입니다.

example1.png

위 격자에서 가장 많은 칸을 거치는 경로는 3개의 칸을 거친다는 것을 알 수 있습니다.

삼각형 격자의 색깔 분포를 나타내는 문자열 배열 grid가 매개변수로 주어집니다. 주어진 격자에 입장했다가 퇴장하는 경로들 중에서, 가장 많은 칸을 거치는 경로를 찾아, 그 경로가 거치는 칸의 개수를 return 하도록 solution 함수를 완성해주세요. 이때, 한번 지나간 칸을 다시 한번 지나가는 것도 중복해서 세야 합니다.

제한사항
grid의 길이는 1 이상 200 이하입니다.
grid의 모든 문자열은 "R"과 "B"로 이루어져 있습니다.
R은 해당 칸이 빨간색, B는 해당 칸이 파란색 격자임을 나타냅니다.
grid의 i번째 문자열(0부터 시작)의 길이는 2 x i + 1 입니다.
이는 격자의 i번째 행의 색깔 분포를 나타냅니다.
i번째 행의 가장 왼쪽에 있는 작은 정삼각형 칸 부터 순서대로 색깔을 나타냅니다.
각 행의 짝수 번째(0번째 부터 시작하며, 0은 짝수로 가정) 문자는 정방향, 홀수 번째 문자는 역방향 작은 정삼각형의 색깔을 나타냅니다.
입출력 예
grid	result
["B", "RRB"]	3
["R", "BBB", "RBRBR"]	7
["R", "RRR", "RBBBB", "BRRRBRR"]	15
입출력 예 설명
입출력 예 #1

본문의 예시와 같습니다.
입출력 예 #2

격자의 색깔 분포와 가장 많은 칸을 거치는 경로는 다음 그림과 같습니다.
example2.png
입출력 예 #3

격자의 색깔 분포와 가장 많은 칸을 거치는 경로는 다음 그림과 같습니다.
example3.png
12345678910
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// grid_len은 배열 grid의 길이입니다.
// 파라미터로 주어지는 문자열은 const로 주어집니다. 변경하려면 문자열을 복사해서 사용하세요.
int solution(const char* grid[], size_t grid_len) {
    int answer = 0;
    return answer;
}
실행 결과
실행 결과가 여기에 표시됩니다.



4. 전구 n개가 일렬로 나열되어 있습니다. 각 전구는 빨강(R), 초록(G), 혹은 파란(B) 불빛이 들어와 있습니다. 당신은 k개의 연속된 전구를 선택해 아래와 같이 불빛을 한꺼번에 바꿀 수 있는 버튼을 가지고 있습니다.

빨강(R) → 초록(G)
초록(G) → 파랑(B)
파랑(B) → 빨강(R)
단, 전구를 벗어나게 구간을 정할 수는 없습니다. 당신은 버튼을 최소한으로 눌러 전구를 모두 빨간(R) 불빛으로 바꿔야 합니다.

예를 들어 n = 6, k = 3일 때, 전구에 불이 다음과 같이 들어와 있는 경우,

rgb_bulb_1.png

구간을 2번부터 4번 전구로 정해 버튼을 누르면 불빛이 아래와 같이 바뀝니다.

rgb_bulb_2.png

마찬가지로 구간을 4번부터 6번 전구로 정해 버튼을 누르면 불빛이 아래와 같이 바뀝니다.

rgb_bulb_3.png

마지막으로 구간을 3번부터 5번 전구로 정해 버튼을 누르면 불빛이 아래와 같이 바뀝니다. 따라서, 모든 전구를 빨간(R) 불빛으로 바꾸려면 버튼을 적어도 세 번 눌러야 합니다.

rgb_bule_4.png

전구의 개수 n, 불빛을 한꺼번에 바꿀 수 있는 연속된 전구 개수 k, 처음 전구의 상태 bulbs가 매개변수로 주어집니다. 모든 전구를 빨간 불빛으로 바꾸려면 버튼을 최소 몇 번 눌러야 하는지 return 하도록 solution 함수를 완성해주세요.

제한사항
n은 1 이상 200,000 이하인 자연수입니다.
k는 1 이상 n 이하인 자연수입니다.
bulbs는 전구의 상태를 나타내는 문자열로 길이는 n 입니다.
bulbs는 'R', 'G', 'B'로만 이루어져 있습니다.
R은 빨강, G는 초록, B는 파란 불빛의 전구를 나타냅니다.
만약 모든 전구를 빨간 불빛으로 바꿀 수 없다면 -1을 return 해주세요.
입출력 예
n	k	bulbs	result
6	3	"RBGRGB"	3
3	2	"BGG"	-1
4	2	"GBBG"	6
입출력 예 설명
입출력 예 #1

문제의 예시와 같습니다.

입출력 예 #2

버튼을 아무리 눌러도 모든 전구를 빨간 불빛으로 만들 수 없습니다.

입출력 예 #3

다음과 같이 6번 만에 모든 전구를 빨간 불빛으로 만들 수 있습니다.

GBBG → GRRG → GGGG → BBGG → BBBB → RRBB → RRRR

5.팰린드롬(Palindrome)이란 앞에서부터 읽으나 뒤에서부터 읽으나 같은 단어를 말합니다. 예를 들어, "abba"나 "a"와 같은 단어는 팰린드롬이고, "abcda"나 "dc"와 같은 단어는 팰린드롬이 아닙니다.

문자열로 표현된 숫자(ex."131")가 N개 들어있는 배열 P가 주어질 때, 다음 규칙에 따라 배열 원소들을 제거하려고 합니다.

배열에서 임의의 두 수 A, B를 뽑습니다.
두 수 A, B를 AB 또는 BA로 이어붙였을 때 팰린드롬이 된다면 A, B를 배열에서 제거할 수 있습니다. 예를 들어, "21"과 "123"을 뽑았을 때, "21123"은 팰린드롬이 아니지만 "12321"은 팰린드롬이므로 두 개의 수는 배열에서 제거할 수 있습니다.
만약 서로 붙여서 만들어진 숫자가 팰린드롬 숫자가 아니면 배열에서 제거할 수 없습니다.
이와 같은 방식을 반복하여, 배열의 모든 원소를 제거해야 합니다.
예를 들어 N=4, P = ["11","111","11","211"] 가 주어졌을 때,

[case 1]

처음에, 첫 번째 원소인 "11"과 두 번째 원소인 "111"을 뽑습니다.
서로 붙어서 만들어진 숫자 "11111"은 팰린드롬이므로 두 개의 수는 배열에서 제거할 수 있습니다.
배열에 남아 있는 세 번째 원소인 "11"과 네 번째 원소인 "211"을 뽑습니다.
서로 붙어서 만들어진 숫자 "11211"은 팰린드롬이므로 두 개의 수는 배열에서 제거할 수 있습니다.
배열의 모든 원소를 제거했습니다.
[case 2]

처음에, 첫 번째 원소인 "11"과 세 번째 원소인 "11"을 뽑습니다.
서로 붙어서 만들어진 숫자 "1111"은 팰린드롬이므로 두 개의 수는 배열에서 제거할 수 있습니다.
배열에 남아 있는 두 번째 원소인 "111"과 네 번째 원소인 "211"을 뽑습니다.
서로 붙어서 만들어진 숫자 "211111" 또는 "111211"은 팰린드롬이 아니므로 두 개의 수는 배열에서 제거할 수 없습니다.
배열의 모든 원소를 제거하지 못했습니다.
[case 3]

처음에, 첫 번째 원소인 "11"과 네 번째 원소인 "211"을 뽑습니다.
서로 붙어서 만들어진 숫자 "11211"은 팰린드롬이므로 두 개의 수는 배열에서 제거할 수 있습니다.
배열에 남아 있는 두 번째 원소인 "111"과 세 번째 원소인 "11"을 뽑습니다.
서로 붙어서 만들어진 숫자 "11111"은 팰린드롬이므로 두 개의 수는 배열에서 제거할 수 있습니다.
배열의 모든 원소를 제거했습니다.
즉 case1, 3의 두 가지 방식으로 배열의 모든 원소를 제거할 수 있습니다.

우리는 배열에 있는 모든 원소를 제거하기 위해 첫 번째 원소를 몇 번째 원소와 연결해야 하는지 알고 싶습니다. 위의 예시의 경우, 두 번째 원소인 "111"과 연결했을 때(case1)와 네 번째 원소인 "211"을 연결했을 때(case3)입니다.

배열 P가 매개변수로 주어질 때, 배열에 있는 모든 원소를 제거하기 위해 첫 번째 원소를 어느 조각과 연결 해야 하는지 모든 가능한 경우를 찾고, 그 경우에 첫 번째 원소와 연결되는 원소들을 return 하도록 solution 함수를 완성해 주세요. 위의 예시의 경우는 ["111","211"]을 return 하면 됩니다. return 할 때는 배열에 주어진 순서대로 return 해주세요.

제한사항
N : 40 이하의 자연수이며, 문제 규칙상 항상 짝수만 주어집니다.
P의 각 원소 : 자연수가 string형으로 주어지며, 각 문자열의 길이는 1 이상 40 이하입니다. 단, 숫자는 0으로 시작하지 않습니다. (ex. "011")
P의 각 원소를 모두 제거할 수 있는 경우만 주어집니다.
입출력 예
P	answer
["11","111","11","211"]	["111","211"]
["21","123","111","11"]	["123"]
입출력 예 설명
입출력 예 #1
위의 예시와 같습니다.

입출력 예 #2

첫 번째 원소인 "21"과 두 번째 원소인 "123"을 뽑아 연결하면 "12321"이 되고, 이 숫자는 팰린드롬이므로 배열에서 제거합니다. 배열에 남은 세 번째 원소와 네 번째 원소를 뽑아 연결하면 "11111"이 되고, 이 숫자는 팰린드롬이므로 배열에서 제거합니다. 배열의 모든 원소를 제거했으므로 두 번째 원소인 "123"은 첫 번째 원소와 연결했을 때 배열의 모든 원소를 제거할 수 있습니다.

첫 번째 원소인 "21"과 세 번째 원소인 "111"을 뽑아 연결하면 "21111" 또는 "11121"이 되고, 이 숫자는 팰린드롬이 아닙니다. 즉, 첫 번째 원소와 세 번째 원소와 연결했을 때는 배열의 모든 원소를 제거할 수 없습니다.

첫 번째 원소인 "21"과 네 번째 원소인 "11"을 뽑아 연결하면 "2111" 또는 "1121"이 되고, 이 숫자는 팰린드롬이 아닙니다. 즉, 첫 번째 원소와 네 번째 원소와 연결했을 때는 배열의 모든 원소를 제거할 수 없습니다.

최종적으로 두 번째 원소가 속한 ["123"] 을 return 합니다.